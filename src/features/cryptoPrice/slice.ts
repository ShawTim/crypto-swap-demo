import numeral from 'numeral';

import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { getCoinGeckoPrices } from './api';

export enum SupportedCryptos {
  USDC = "USDC",
  WBTC = "WBTC",
  ETH = "ETH",
};

export const CRYPTO_NAMES: { [token: string]: string } = {
  [SupportedCryptos.USDC]: "USDC",
  [SupportedCryptos.WBTC]: "Wrapped Bitcoin",
  [SupportedCryptos.ETH]: "Ethereum",
};

// TODO: fee should be dynamic but for demo purpose let's set it as constant
export const CRYPTO_TXN_FEES: { [token: string]: number } = {
  [SupportedCryptos.USDC]: 1,
  [SupportedCryptos.WBTC]: 0.005,
  [SupportedCryptos.ETH]: 0.005,
};

export type CryptoPriceObject = {
  USD: number,
  [SupportedCryptos.USDC]: number,
  [SupportedCryptos.WBTC]: number,
  [SupportedCryptos.ETH]: number,
};

export type CryptoPriceState = {
  [SupportedCryptos.USDC]: CryptoPriceObject,
  [SupportedCryptos.WBTC]: CryptoPriceObject,
  [SupportedCryptos.ETH]: CryptoPriceObject,
};

const initialState: CryptoPriceState = {
  [SupportedCryptos.USDC]: {
    USD: 0,
    [SupportedCryptos.USDC]: 1,
    [SupportedCryptos.WBTC]: 0,
    [SupportedCryptos.ETH]: 0,
  },
  [SupportedCryptos.WBTC]: {
    USD: 0,
    [SupportedCryptos.USDC]: 0,
    [SupportedCryptos.WBTC]: 1,
    [SupportedCryptos.ETH]: 0,
  },
  [SupportedCryptos.ETH]: {
    USD: 0,
    [SupportedCryptos.USDC]: 0,
    [SupportedCryptos.WBTC]: 0,
    [SupportedCryptos.ETH]: 1,
  },
};

export const getCoinGeckoPricesAsync = createAsyncThunk(
  'cryptoPrice/getCoinGeckoPrices',
  getCoinGeckoPrices
);

export const cryptoPriceSlice = createSlice({
  name: 'cryptoPrice',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getCoinGeckoPricesAsync.fulfilled, (state, action) => {
        // the API from CoinGecko doesnt provide price for every pair, so need to calculate through USD price
        const usd2usdc = numeral(1).divide(action.payload[SupportedCryptos.USDC].usd || 1).value();
        const usd2wbtc = numeral(1).divide(action.payload[SupportedCryptos.WBTC].usd || 1).value();
        state[SupportedCryptos.USDC].USD = action.payload[SupportedCryptos.USDC].usd;
        state[SupportedCryptos.USDC][SupportedCryptos.WBTC] = numeral(action.payload[SupportedCryptos.USDC].usd).multiply(usd2wbtc).value() || 0;
        state[SupportedCryptos.USDC][SupportedCryptos.ETH] = action.payload[SupportedCryptos.USDC].eth;
        state[SupportedCryptos.WBTC].USD = action.payload[SupportedCryptos.WBTC].usd;
        state[SupportedCryptos.WBTC][SupportedCryptos.USDC] = numeral(action.payload[SupportedCryptos.WBTC].usd).multiply(usd2usdc).value() || 0;
        state[SupportedCryptos.WBTC][SupportedCryptos.ETH] = action.payload[SupportedCryptos.WBTC].eth;
        state[SupportedCryptos.ETH].USD = action.payload[SupportedCryptos.ETH].usd;
        state[SupportedCryptos.ETH][SupportedCryptos.USDC] = numeral(action.payload[SupportedCryptos.ETH].usd).multiply(usd2usdc).value() || 0;
        state[SupportedCryptos.ETH][SupportedCryptos.WBTC] = numeral(action.payload[SupportedCryptos.ETH].usd).multiply(usd2wbtc).value() || 0;
      });
  },
});

export default cryptoPriceSlice.reducer;
